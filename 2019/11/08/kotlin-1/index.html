<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="MicroStudent"><title>kotlin协程——概念入门 · MicroStudent的博客</title><meta name="description" content="近期在学习kotlin相关知识，看到协程这块的知识，觉得对java程序员来说，是一个比较新颖的概念，而且加上之前面试的时候也被问过相关概念，遂对协程进行了一番了解。
本文结合参考了大量知名博主的博文的写作思路，加上自己对协程的一些认知，编写而成，如有雷同，尽请谅解。

现在都9102年了，Googl"><meta name="keywords" content="Android,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">MicroStudent的博客</a></h3><div class="description"><p>I love learning.</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/1572542140"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/microstudent"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/assets/images/avatar.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>kotlin协程——概念入门</a></h3></div><div class="post-content"><p>近期在学习kotlin相关知识，看到协程这块的知识，觉得对java程序员来说，是一个比较新颖的概念，而且加上之前面试的时候也被问过相关概念，遂对协程进行了一番了解。</p>
<p>本文结合参考了大量知名博主的博文的写作思路，加上自己对协程的一些认知，编写而成，如有雷同，尽请谅解。</p>
<hr>
<p>现在都9102年了，Google也开始强推Kotlin作为主打的Android编程语言，作为一线开发人员，此时不学一点kotlin，更待何时？</p>
<p>本次分享我将会介绍kotlin里面，对于java程序员而言，比较新颖的特性——协程。</p>
<ol>
<li>什么是协程；</li>
<li>协程怎么写；</li>
<li>协程和线程的关系；</li>
<li>关于协程的一些误区；</li>
</ol>
<h2 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h2><p>小伙伴们肯定知道什么是进程和线程。</p>
<p>什么是进程和线程？必备面试题答案：</p>
<blockquote>
<ul>
<li><p>进程是一个应用程序的一个实例，拥有应用程序打开的资源，有独立的内存空间，进程之间无法相互访问资源。</p>
</li>
<li><p>线程是最小的可执行单位，一个进程可能含有多个线程，但一个线程只能从属于一个进程，线程之间共享进程的资源，可以互相访问，有自己的栈空间。</p>
</li>
<li><p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong></p>
<p><img src="https://www.itcodemonkey.com/data/upload/portal/20180620/1529501500758053.jpg" alt="img" style="zoom: 90%;"></p>
</li>
</ul>
</blockquote>
<p>协程的名字听起来和进程、线程有点相似，那么他们是不是一回事呢？</p>
<h3 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h3><p>我们思考进程和线程的诞生过程：</p>
<ul>
<li>我们为了解决同一时刻运行多个程序的需求，我们通过分配CPU时间片，有了<strong>并发</strong>的概念；</li>
<li>我们并发时，资源需要来回切换，为了保存中间态，达到<strong>上下文切换</strong>，我们有了<strong>进程</strong>的概念；</li>
<li>后来有了多个CPU，我们可以真正意义上同时运行多个程序，于是我们有了<strong>并行</strong>的概念；</li>
<li>为了解决反复切换内核态和用户态，频繁切换资源带来的性能低下，我们有了<strong>线程</strong>的概念，一个地方阻塞了，CPU不需要切换到其他进程，不需要进入内核态，同一进程下的多个线程还可以继续做其他事情，减少了性能损失；</li>
<li>为了做到一个函数或者一段程序（我们称他为A函数）他执行的过程中可以被挂起（暂停），去做其他事情（B函数），做完之后再回到A函数，（利用或不利用A函数的结果）继续执行剩下A函数逻辑，我们有了<strong>协程</strong>的概念；</li>
</ul>
<blockquote>
<p>关于并发和并行：并行和并发看起来概念接近，但两者有本质上的区别。正因为 CPU 时间片足够小，即便一个单核的 CPU，也可以给我们营造多任务同时运行的假象，这就是所谓的“并发”。并行才是真正的同时运行。并发的话，更像是一种障眼法。</p>
</blockquote>
<p>从上面的描述来看，其实协程没那么复杂。协程是一个抽象的概念，他可以做到自行挂起恢复，做到多协程协作运行。它跟线程最大的区别在于线程一旦开始执行，从任务的角度来看，就不会被暂停，直到任务结束这个过程都是连续的，线程之间是抢占式的调度，因此也不存在协作问题。</p>
<h3 id="协程的分类"><a href="#协程的分类" class="headerlink" title="协程的分类"></a>协程的分类</h3><p>因为协程的概念比较模糊，上面说的挂起和恢复具体怎么做，也没有一个标准实现，各种语言都有他们自己的理解和实现，因此协程会给人一种摸不清头脑的感觉。</p>
<p>相对于线程来说，线程是由操作系统实现的，主流的操作系统都有成熟的线程模型，因此编程语言基本都是照搬操作系统的线程来实现。</p>
<p>协程基本都是语言层面各自的实现，每个语言都有不同的使用场景，甚至像java自己本身都没有官方的协程实现，只有一些比较冷门的开源框架（比如<a href="http://docs.paralleluniverse.co/quasar/" target="_blank" rel="noopener">Quasar</a>）对协程进行实现。</p>
<hr>
<p>先来一个无奖竞猜：以下代码中，我们分别在Activity的OnCreate中，分别用两种方式（线程的sleep和协程的delay），延迟1000ms之后，弹出一条HelloWorld的Toast。</p>
<p>请问他们有什么区别吗？他们都会阻塞主线程吗？如果你知道答案，你能大概讲一下他们写成java代码的时候大概是什么样子吗？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity1</span> : <span class="type">AppCompatActivity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        delay1()</span><br><span class="line">        delay2()</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//代码一</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)<span class="comment">//sleep 1000ms</span></span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"HelloWorld"</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//代码二</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay2</span><span class="params">()</span></span> &#123;</span><br><span class="line">        launch &#123;<span class="comment">//启动一个协程</span></span><br><span class="line">            delay(<span class="number">1000</span>)<span class="comment">//delay 1000ms</span></span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity1</span>, <span class="string">"HelloWorld"</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案先不公布，最后再进行解答。</p>
<hr>
<h3 id="用协程改造网络请求代码"><a href="#用协程改造网络请求代码" class="headerlink" title="用协程改造网络请求代码"></a>用协程改造网络请求代码</h3><p>我们平时如果需要发起一个网络请求，一般是怎么做的？</p>
<p>如果我们用的是Retrofit，那么代码可能是下面这样的：</p>
<ol>
<li>先定义一个Api</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;user&#125;/city"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserCity</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"user"</span>)</span> user: <span class="type">String</span>)</span></span>: Call&lt;String&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>请求网络的时候</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitHubServiceApi.getUserCity(<span class="string">"test"</span>).enqueue(<span class="keyword">object</span> : Callback&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">String</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        handler.post &#123; showError(t) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">String</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        handler.post &#123; response.body()?.let(::showUserCity) ?: showError(NullPointerException()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>请求结果回来之后，如果不是在UI现场，我们需要手动切换到UI线程来展示结果。这类代码大量存在于我们的逻辑当中，它有什么问题呢？</p>
<ul>
<li>通过 Lambda 表达式，我们让线程切换变得不是那么明显，但它仍然存在，一旦开发者出现遗漏，这里就会出现问题</li>
<li>回调嵌套了两层，看上去倒也没什么，但真实的开发环境中逻辑一定比这个复杂的多，例如登录失败的重试</li>
<li>重复或者分散的异常处理逻辑，在请求失败时我们调用了一次 <code>showError</code>，在数据读取失败时我们又调用了一次，真实的开发环境中可能会有更多的重复</li>
</ul>
<blockquote>
<p>假如你使用过Rxjava，你可能会想要使用Rxjava解决这个问题。Rxjava本身也是一种很好的解决这类问题的方案，但是他的操作符太繁琐了，上手门槛较高。</p>
</blockquote>
<p>引入一个开源库</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'</span></span><br></pre></td></tr></table></figure>
<p>我们可以直接改造api接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(<span class="meta-string">"users/&#123;user&#125;/city"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserCity</span><span class="params">(<span class="meta">@Path(<span class="meta-string">"user"</span>)</span> user: <span class="type">String</span>)</span></span>: Deferred&lt;String&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造Retrofit实例时，添加：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> gitHubServiceApi <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofit = retrofit2.Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .addCallAdapterFactory(CoroutineCallAdapterFactory())<span class="comment">//添加对 Deferred 的支持</span></span><br><span class="line">            .build()</span><br><span class="line">    retrofit.create(GitHubServiceApi::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以这么调用这个api方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        showUser(gitHubServiceApi.getUserCity(<span class="string">"test"</span>).await())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用看似同步的代码来执行了这段代码，当原有的回调返回了onFailure或者被cancel，都会抛出异常，走到showError处。</p>
<p>那么黑魔法发生在哪里呢？</p>
<p>我们通过GlobalScope.launch启动了一个协程，类似我们通过以下代码启动一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">   <span class="comment">//...run something</span></span><br><span class="line"> &#125;).start();</span><br></pre></td></tr></table></figure>
<p>GlobalScope是一个协程作用域的概念，涉及到协程的取消和异常传递。因为时间关系不细讲这个类。</p>
<p>他的launch方法签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext, <span class="comment">// 上下文，很多作用，包括写代参数，拦截协程执行等</span></span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,  <span class="comment">// 启动模式，默认是DEFAULT模式启动</span></span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.()</span></span> -&gt; <span class="built_in">Unit</span> <span class="comment">// 协程体，类似我们Thread的Runnable</span></span><br><span class="line">): Job</span><br></pre></td></tr></table></figure>
<p>方法参数中的上下文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;Dispatchers.Main定义的主线程随平台不同而不同，在android中是UI线程，在 Java Swing 上为 `SwingDispatcher` 等等。</span><br><span class="line"></span><br><span class="line">启动模式本身的概念不是很复杂，我们发现参数的默认参数是``` CoroutineStart.DEFAULT```，这代表了他会在launch调用之后立即启动，不需要像新建线程一样，需要调用start方法。</span><br><span class="line"></span><br><span class="line">&gt; 除了Default之外，还有以下模式，他们可以做到饿汉式和懒汉式启动协程的作用。具体不再详细介绍，可以参考bennyhuo老师的[这篇博文](https://www.bennyhuo.com/2019/04/08/coroutines-start-mode/)</span><br><span class="line">&gt;</span><br><span class="line">&gt; | 模式         | 功能                                              |</span><br><span class="line">&gt; | :----------- | :------------------------------------------------ |</span><br><span class="line">&gt; | DEFAULT      | 立即执行协程体                                    |</span><br><span class="line">&gt; | ATOMIC       | 立即执行协程体，但在开始运行之前无法取消          |</span><br><span class="line">&gt; | UNDISPATCHED | 立即在当前线程执行协程体，直到第一个 suspend 调用 |</span><br><span class="line">&gt; | LAZY         | 只有在需要的情况下运行                            |</span><br><span class="line"></span><br><span class="line">最后是我们作为一个Lambda表达式传入的协程体，他和我们在Thread里面写的Runnable一样，是协程运行是执行的代码。</span><br><span class="line"></span><br><span class="line">重新看一下这段代码：</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        showUser(gitHubServiceApi.getUserCity(&quot;test&quot;).await())</span><br><span class="line">    &#125; catch (e: Exception) &#123;</span><br><span class="line">        showError(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们仔细看代码，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其实```getUserCity```在执行的时候确实切换到了其他线程，但是返回结果的时候，我们通过await方法，从Deferred中拿到了结果，我们又回到了UI线程。</span><br><span class="line"></span><br><span class="line">我们也许会联想到Java里面有一个叫Future的东西，他也能做到这种效果。看起来，线程是阻塞在这里，等待线程执行完成，返回结果再继续执行吧？但是这可是UI线程，这样不会阻塞UI线程吗？</span><br><span class="line"></span><br><span class="line">答案是不会。这是一种**非阻塞式挂起**。关于非阻塞式挂起的一个定义，在下面进行了解释。</span><br><span class="line"></span><br><span class="line">我们看看await方法是怎么实现的：</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">    public suspend fun await(): T</span><br></pre></td></tr></table></figure></p>
<p>他是一个suspend方法，这意味着他是一个可能会执行很长时间的方法，只能在另外一个suspend方法中调用。</p>
<p>看起来他是同步返回的方法，他直接就返回了结果，但是事实上这是编译器给我们的障眼法，我们反编译之后可以看到，他本质上是类似这么的一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kotlinx/coroutines/Deferred.await (Lkotlin/coroutines/Continuation;)Ljava/lang/Object;</span><br></pre></td></tr></table></figure>
<p>方法其实并不是一个空入参的方法，而是传入了一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">public interface Continuation&lt;in T&gt; &#123;</span><br><span class="line">    public val context: CoroutineContext</span><br><span class="line">    public fun resume(value: T)</span><br><span class="line">    public fun resumeWithException(exception: Throwable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>resume和resumeWithException不就对应刚刚代码里面的继续执行和抛出异常吗？那么这段代码不就是一个java的经典的回调用法吗？只是编译器让我们忽略了这个细节，将回调变成了同步代码执行的方式运行，这样就避免了java的著名的<strong>回调地狱</strong>的问题。</p>
<p>现在我们再回过头来看看，Deferred.await()和Future.get()他们是一回事吗？并不是，Deferred.await()是编译器巧妙地让回调变成了同步方法，并不阻塞运行，而Future.get()是真实的阻塞的线程的运行。</p>
<p>我们讲了这么多其实想表达的就是，其实运行机制上，协程和回调没有太大区别。</p>
<h3 id="协程好在哪里？"><a href="#协程好在哪里？" class="headerlink" title="协程好在哪里？"></a>协程好在哪里？</h3><p>我们可以看到上述的代码，从一个异步回调式的代码，变成了一个类似同步的代码逻辑。异步回调式的代码会降低代码可读性，提高复杂度。在需要切换线程的场合里，这个问题还会变的异常复杂。而协程可以很优雅的处理这些问题。</p>
<h3 id="协程的定义"><a href="#协程的定义" class="headerlink" title="协程的定义"></a>协程的定义</h3><p>这是维基百科对协程的定义：</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>
</blockquote>
<p>引用bennyhuo老师对协程的定义：</p>
<blockquote>
<p>简单来说就是，协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。我们在 Java 虚拟机上所认识到的线程大多数的实现是映射到内核的线程的，也就是说线程当中的代码逻辑在线程抢到 CPU 的时间片的时候才可以执行，否则就得歇着，当然这对于我们开发者来说是透明的；而经常听到所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他这么重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式的。</p>
</blockquote>
<h3 id="一些名词解释"><a href="#一些名词解释" class="headerlink" title="一些名词解释"></a>一些名词解释</h3><p><strong>非阻塞式挂起</strong>：就像我们刚刚说的，await并不会阻塞当前线程，但是他是对当前协程的一个挂起，所以他是非阻塞式的挂起，我们称不阻塞线程的挂起就叫非阻塞式挂起</p>
<p><strong>非抢占式</strong>/<strong>协作式</strong>：非抢占式和协作式的定义类似，是一种调度方式，让程序自己决定要运行到什么时候，出让自己的控制权，直到结束的调度方式。kotlin的协程是从逻辑上达到这种效果，代码当然还是在线程上运行，并不能完全独占一个CPU。</p>
<p><strong>抢占式</strong>：一种调度方式，由CPU决定给每个线程的时间片，如果一个线程用完当前分配给它的时间片，将由操作系统决定下一次占用CPU的线程。</p>
<hr>
<p>所以我们回过头来看之前那个delay和sleep的区别，你现在还能知道他们的区别吗？</p>
<p>我们可以大概模拟出来他们在java语言下的模样，其实delay就是在其他地方等待了1000ms，再通过一个隐藏的回调，调用了剩余的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅为模拟，解释相关概念，并不代表他们在执行时真实的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        delay1();</span><br><span class="line">        delay2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delay1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            Toast.makeText(MainActivity2.<span class="keyword">this</span>, <span class="string">"HelloWorld"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delay2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity2.<span class="keyword">this</span>, <span class="string">"HelloWorld"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="在Android中协程怎么用？"><a href="#在Android中协程怎么用？" class="headerlink" title="在Android中协程怎么用？"></a>在Android中协程怎么用？</h2><p>我们解释了一大堆概念，我们可以开始上手，看看kotlin的协程到底应该怎么用，可以怎么用。</p>
<h3 id="如何创建一个协程"><a href="#如何创建一个协程" class="headerlink" title="如何创建一个协程"></a>如何创建一个协程</h3><p>launch并不是一个顶层函数，他需要通过一个CoroutineScope作用域来发起。我们可以通过以下几种方式创建一个协程</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一，使用 runBlocking 顶层函数</span></span><br><span class="line">runBlocking &#123;</span><br><span class="line">    getImage(imageId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，使用 GlobalScope 单例对象</span></span><br><span class="line"><span class="comment">//  可以直接调用 launch 开启协程</span></span><br><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    getImage(imageId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三，自行通过 CoroutineContext 创建一个 CoroutineScope 对象</span></span><br><span class="line"><span class="comment">// 需要一个类型为 CoroutineContext 的参数</span></span><br><span class="line"><span class="keyword">val</span> coroutineScope = CoroutineScope(context)</span><br><span class="line">coroutineScope.launch &#123;</span><br><span class="line">    getImage(imageId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于runBlocking和launch的区别，看以下代码就知道了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">"1"</span>)</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        println(<span class="string">"2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">"4"</span>)</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">"5"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"6"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>可以看到runBlocking阻塞了当前线程，直到协程体结束才会继续往下执行。一般不会直接使用runBlocking编写代码。</p>
<p>方法二就是我们一直在用的创建协程的方式。</p>
<p>方法三就是通过自定义协程作用域来创建协程。android有一个MainScope可以很方便绑定与组件的生命周期。</p>
<p>关于 <code>CoroutineScope</code> 和 <code>CoroutineContext</code> 时间有限本次不讲，同学们可以自己查找相关文档。</p>
<h3 id="在Android中引入协程"><a href="#在Android中引入协程" class="headerlink" title="在Android中引入协程"></a>在Android中引入协程</h3><p>kotlin的主要用户是android开发，因此我们也有针对android开发的协程配套库，在android项目中引用：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1'</span></span><br></pre></td></tr></table></figure>
<p>这个框架里面包含了 Android 专属的 <code>Dispatcher</code>，我们可以通过 <code>Dispatchers.Main</code> 来拿到这个实例；也包含了 <code>MainScope</code>，用于与 Android 作用域相结合。</p>
<h3 id="使用MainScope绑定协程和Activity生命周期"><a href="#使用MainScope绑定协程和Activity生命周期" class="headerlink" title="使用MainScope绑定协程和Activity生命周期"></a>使用MainScope绑定协程和Activity生命周期</h3><p>我们可以这么写一个Activity应用MainScope：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">  <span class="comment">//CoroutineScope by MainScope()的作用类似于下面这一句。</span></span><br><span class="line">  <span class="comment">//   val mainScope = MainScope()</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//..doSomething</span></span><br><span class="line">        tv_main.text = async(Dispatchers.IO)&#123;</span><br><span class="line">          					<span class="comment">//get Data</span></span><br><span class="line">                    delay(<span class="number">1000</span>)</span><br><span class="line">                    <span class="string">"Hello World1"</span></span><br><span class="line">                &#125;.await()</span><br><span class="line">        </span><br><span class="line">         launch &#123;</span><br><span class="line">                    <span class="keyword">val</span> text = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                        delay(<span class="number">1000</span>)</span><br><span class="line">                        <span class="string">"Hello World2"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    tv_main.text = text</span><br><span class="line">                &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        <span class="comment">//取消MainScope作用域里面的所有正在执行的协程</span></span><br><span class="line">        cancel()</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过接口委托，使得MainActivity有了CoroutineScope的相关方法。此时，他的launch方法默认运行在主线程，同时，我们能够结合生命周期，在Activity的onDestroy时，主动取消正在执行的协程。</p>
<h3 id="谨慎使用GlobalScope"><a href="#谨慎使用GlobalScope" class="headerlink" title="谨慎使用GlobalScope"></a>谨慎使用GlobalScope</h3><p>正如同他的名字一样，GlobalScope是一个顶级全局作用域，他的生命周期不被android的组件所控制。如果使用GlobalScope启动协程，那么MainScope就没有起到应有的作用。</p>
<h3 id="使用协程发起多个请求并组合完成"><a href="#使用协程发起多个请求并组合完成" class="headerlink" title="使用协程发起多个请求并组合完成"></a>使用协程发起多个请求并组合完成</h3><p>假如我们需要实现个人中心页，用户的昵称和头像是不同接口返回的，我们需要将两个接口的返回组合，一起展示在页面上。（当然实际上图片我们一般是占位图先显示，这里仅仅是模拟一种场景）</p>
<p>如果没有协程，我们可能需要有两个线程同时发起请求，然后用一个同步锁来并同步两者的节奏，让他们能够最后一起展现在用户面前。</p>
<p>如果我们对自己的异步代码写的不够自信，还可能写出先执行一个请求，返回后再执行另外一个请求的辣鸡代码。</p>
<p>如果有了协程，我们可以这么实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的实现，实际情况还要考虑失败，取消等情况</span></span><br><span class="line">coroutineScope.launch(Dispatchers.Main) &#123;       <span class="comment">// 开始协程：主线程</span></span><br><span class="line">    <span class="keyword">val</span> avatar = async&#123;api.getAvatar()&#125;         <span class="comment">// 网络请求：IO 线程</span></span><br><span class="line">    <span class="keyword">val</span> user = async&#123;api.getUser()&#125;             <span class="comment">// 网络请求：IO 线程</span></span><br><span class="line">    <span class="keyword">val</span> merged = suspendingMerge(avatar,user)   <span class="comment">// 组合结果，自定义方法</span></span><br><span class="line">  	<span class="comment">//setVisibility </span></span><br><span class="line">  	show()																			<span class="comment">// 更新 UI：主线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用withContext方便的切换线程"><a href="#使用withContext方便的切换线程" class="headerlink" title="使用withContext方便的切换线程"></a>使用withContext方便的切换线程</h3><p>我们可以依靠withContext，方便的把线程切换到其他地方，执行耗时操作，再返回当前线程继续执行代码。详见以下例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispachers.Main) &#123;              <span class="comment">// 在 UI 线程开始</span></span><br><span class="line">    <span class="keyword">val</span> image = getImage(imageId)</span><br><span class="line">    avatarIv.setImageBitmap(image)     <span class="comment">// 执行结束后，自动切换回 UI 线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getImage</span><span class="params">(imageId: <span class="type">Int</span>)</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现生产者消费者模型"><a href="#实现生产者消费者模型" class="headerlink" title="实现生产者消费者模型"></a>实现生产者消费者模型</h3><p>思考题：我们先思索一下，一个最经典的生产者消费者模式是怎样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者和消费者，wait()和notify()的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULL = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK = <span class="string">"lock"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestConsumer1 test1 = <span class="keyword">new</span> TestConsumer1();</span><br><span class="line">        <span class="keyword">new</span> Thread(test1.new Producer()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test1.new Consumer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == FULL) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"生产者队列满了，等待消费"</span> + count);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"生产者生产，目前总共有"</span> + count);</span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"消费者者队列空了，等待生产"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"消费者消费，目前总共有"</span> + count);</span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他有什么性能问题？</p>
<ul>
<li>通过同步锁实现了线程同步</li>
<li>每个线程可能会在wait和可运行状态之间来回切换</li>
<li>涉及到线程的上下文切换</li>
</ul>
<p>如果同样一段代码，使用kotlin的协程来写，是怎样的写法呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.Channel</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangshuyue</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//val channel = Channel&lt;Int&gt;(Channel.UNLIMITED)//可以指定容量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                println(<span class="string">"before send <span class="variable">$i</span>"</span>)</span><br><span class="line">                channel.send(i++)</span><br><span class="line">                println(<span class="string">"after send <span class="variable">$i</span>"</span>)</span><br><span class="line">                delay(<span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                delay(<span class="number">2000</span>) <span class="comment">//receive 之前延迟 2s</span></span><br><span class="line">                <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">                println(element)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        producer.join()</span><br><span class="line">        consumer.join()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于协程的一些误区"><a href="#关于协程的一些误区" class="headerlink" title="关于协程的一些误区"></a>关于协程的一些误区</h2><ol>
<li>协程效率很高，可以取代线程</li>
</ol>
<p>协程的效率来自他不需要进入内核态，不需要刷新CPU高速缓存，在用户态就可以切换执行内容。</p>
<blockquote>
<p>编程语言级别实现的协程就是程序内部的逻辑，不会涉及操作系统的资源之间的切换，操作系统的内核线程自然会重一些，且不说每创建一个线程就会开辟的栈带来的内存开销，线程在上下文切换的时候需要 CPU 把高速缓存清掉并从内存中替换下一个线程的内存数据，并且处理上一个内存的中断点保存就是一个开销很大的事儿。</p>
</blockquote>
<p>简单的说，kotlin上的协程是通过线程池封装实现，从这个角度来说，如果是需要来回切换协程的任务，我们使用协程来优化，能够达到很好的效率。但是不要抱有不切实际的幻想，认为协程可以优化一切代码，比线程高一等。</p>
<ol start="2">
<li>协程一定是单线程的</li>
</ol>
<p>协程不一定都是单线程的，一般来说，协程可以运行在单线程，也可以运行在多线程，这取决于他的实现。kotlin可以跑在java虚拟机上，也可以跑在JavaScript和native上，这些情况不能一概而论。</p>
<ol start="3">
<li>协程是对线程池的一个封装</li>
</ol>
<p>在kotlin上，这句话从实现上可以这么理解，协程确实是在线程池的基础上开发出来的。但协程和线程池概念上有区别，不能完全等同，他们是两个不同的角色。</p>
<ol start="4">
<li>协程的挂起是非阻塞式的，线程是阻塞式的</li>
</ol>
<p>所谓的非阻塞式指的是不阻塞当前线程，从一开始介绍的例子来看，协程的挂起是通过切换线程来达成的，他线程都切走了，当然不会卡当前线程，所以他是非阻塞式的。所谓的线程是阻塞式的，指的是单线程中的等待，当然是阻塞式的，如果通过切线程，把阻塞任务抛到异步线程中去，那么当前线程当然也是非阻塞式的。</p>
<ol start="5">
<li>协程不需要加锁</li>
</ol>
<p>这是有问题的，协程在kotlin上的实现就是线程池，有可能出现多线程执行的，既然是多线程，那就有线程同步问题。</p>
<h2 id="参阅资料"><a href="#参阅资料" class="headerlink" title="参阅资料"></a>参阅资料</h2><p>[1] bennyhuo老师的博客 <a href="https://www.bennyhuo.com/" target="_blank" rel="noopener">https://www.bennyhuo.com/</a></p>
<p>[2]  扔物线老师的教程 <a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">https://kaixue.io/kotlin-coroutines-1/</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-08</span><i class="fa fa-tag"></i><a class="tag" href="/tags/kotlin-协程/" title="kotlin 协程">kotlin 协程 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://microstudent.github.io/2019/11/08/kotlin-1/,MicroStudent的博客,kotlin协程——概念入门,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/09/10/android-hack1/" title="一个由SharedPreferences引起的ANR">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>